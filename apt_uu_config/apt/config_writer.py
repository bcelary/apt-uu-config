"""Write APT and unattended-upgrades configuration files."""

import shutil
from pathlib import Path

from apt_uu_config.models.origin import Origin


class ConfigWriter:
    """
    Write APT configuration files related to unattended upgrades.

    This class handles writing:
    - /etc/apt/apt.conf.d/20auto-upgrades (global enable/disable)
    - /etc/apt/apt.conf.d/50unattended-upgrades (origin configuration)
    """

    def __init__(self, config_dir: Path = Path("/etc/apt")) -> None:
        """
        Initialize the ConfigWriter.

        Args:
            config_dir: Base directory for APT configuration (default: /etc/apt)
        """
        self.config_dir = config_dir
        self.AUTO_UPGRADES_PATH = config_dir / "apt.conf.d" / "20auto-upgrades"
        self.UNATTENDED_UPGRADES_PATH = config_dir / "apt.conf.d" / "50unattended-upgrades"

    def set_globally_enabled(self, enabled: bool) -> None:
        """
        Enable or disable unattended upgrades globally.

        Args:
            enabled: True to enable, False to disable
        """
        # Backup existing file
        if self.AUTO_UPGRADES_PATH.exists():
            self._backup_file(self.AUTO_UPGRADES_PATH)

        # Create the configuration content
        value = "1" if enabled else "0"
        content = f"""APT::Periodic::Update-Package-Lists "{value}";
APT::Periodic::Unattended-Upgrade "{value}";
"""

        try:
            self.AUTO_UPGRADES_PATH.write_text(content)
        except PermissionError:
            raise PermissionError(
                f"Permission denied writing to {self.AUTO_UPGRADES_PATH}. " "Try running with sudo."
            )
        except Exception as e:
            raise RuntimeError(f"Error writing to {self.AUTO_UPGRADES_PATH}: {e}") from e

    def add_origin(self, origin: Origin) -> None:
        """
        Add an origin to the unattended-upgrades configuration.

        Args:
            origin: The origin to add
        """
        if not self.UNATTENDED_UPGRADES_PATH.exists():
            # Create a basic configuration file
            self._create_default_config()

        # Backup existing file
        self._backup_file(self.UNATTENDED_UPGRADES_PATH)

        try:
            content = self.UNATTENDED_UPGRADES_PATH.read_text()
            updated_content = self._add_origin_to_config(content, origin)
            self.UNATTENDED_UPGRADES_PATH.write_text(updated_content)
        except PermissionError:
            raise PermissionError(
                f"Permission denied writing to {self.UNATTENDED_UPGRADES_PATH}. "
                "Try running with sudo."
            )
        except Exception as e:
            raise RuntimeError(f"Error writing to {self.UNATTENDED_UPGRADES_PATH}: {e}") from e

    def remove_origin(self, origin: Origin) -> None:
        """
        Remove an origin from the unattended-upgrades configuration.

        Args:
            origin: The origin to remove
        """
        if not self.UNATTENDED_UPGRADES_PATH.exists():
            return

        # Backup existing file
        self._backup_file(self.UNATTENDED_UPGRADES_PATH)

        try:
            content = self.UNATTENDED_UPGRADES_PATH.read_text()
            updated_content = self._remove_origin_from_config(content, origin)
            self.UNATTENDED_UPGRADES_PATH.write_text(updated_content)
        except PermissionError:
            raise PermissionError(
                f"Permission denied writing to {self.UNATTENDED_UPGRADES_PATH}. "
                "Try running with sudo."
            )
        except Exception as e:
            raise RuntimeError(f"Error writing to {self.UNATTENDED_UPGRADES_PATH}: {e}") from e

    def _backup_file(self, file_path: Path) -> None:
        """
        Create a backup of a configuration file.

        Args:
            file_path: Path to the file to backup
        """
        backup_path = file_path.with_suffix(file_path.suffix + ".bak")
        shutil.copy2(file_path, backup_path)

    def _create_default_config(self) -> None:
        """Create a default unattended-upgrades configuration file."""
        # Ensure the directory exists
        self.UNATTENDED_UPGRADES_PATH.parent.mkdir(parents=True, exist_ok=True)

        default_content = """// Unattended-Upgrade::Allowed-Origins configuration
// Automatically generated by apt-unattended-config

Unattended-Upgrade::Allowed-Origins {
};

Unattended-Upgrade::DevRelease "false";
Unattended-Upgrade::AutoFixInterruptedDpkg "true";
Unattended-Upgrade::MinimalSteps "true";
"""
        self.UNATTENDED_UPGRADES_PATH.write_text(default_content)

    def _add_origin_to_config(self, content: str, origin: Origin) -> str:
        """
        Add an origin pattern to the configuration content.

        Args:
            content: Current configuration content
            origin: Origin to add

        Returns:
            Updated configuration content
        """
        # Create the origin pattern line
        pattern = f'        "origin={origin.origin},suite={origin.suite}";\n'

        # Find the Allowed-Origins section and add the pattern
        import re

        # Look for Unattended-Upgrade::Allowed-Origins { ... }
        match = re.search(
            r"(Unattended-Upgrade::Allowed-Origins\s*\{)([^}]*)(};)",
            content,
            re.DOTALL,
        )

        if match:
            # Check if this origin already exists
            if pattern.strip() not in match.group(2):
                # Add the new pattern
                new_section = match.group(1) + match.group(2) + pattern + match.group(3)
                content = content[: match.start()] + new_section + content[match.end() :]

        return content

    def _remove_origin_from_config(self, content: str, origin: Origin) -> str:
        """
        Remove an origin pattern from the configuration content.

        Args:
            content: Current configuration content
            origin: Origin to remove

        Returns:
            Updated configuration content
        """

        # Create the pattern to match this origin
        pattern = f'"origin={origin.origin},suite={origin.suite}";'

        # Remove lines matching this pattern
        lines = content.split("\n")
        filtered_lines = [line for line in lines if pattern.lower() not in line.lower()]

        return "\n".join(filtered_lines)
